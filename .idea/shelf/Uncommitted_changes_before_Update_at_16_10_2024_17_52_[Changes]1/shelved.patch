Index: recetario.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/recetario.py b/recetario.py
--- a/recetario.py	(revision 341eff7c711caf55b31b783511e6d377ac277e1f)
+++ b/recetario.py	(date 1729093500309)
@@ -1,0 +1,172 @@
+from pathlib import Path
+import os
+from os import system
+
+mi_ruta = Path(Path.home(), "Desktop", "Recetas")
+
+def contar_recetas(ruta):
+    contador = 0
+    for txt in Path(ruta).glob("**/*.txt"):
+        contador += 1
+    return contador
+
+def inicio():
+    system("cls")
+    print('*' * 50)
+    print('*' * 5 + " Bienvenido al administrador de recetas " + '*' * 5)
+    print('*' * 50)
+    print('\n')
+    print(f"Las recetas se encuentran en {mi_ruta}")
+    print(f"Total recetas: {contar_recetas(mi_ruta)}")
+
+    eleccion_menu = 'x'
+    while not eleccion_menu.isnumeric() or int(eleccion_menu) not in range(1,7):
+        print("Elige una opción: ")
+        print('''
+        [1] - Leer receta
+        [2] - Crear receta nueva
+        [3] - Crear categoria nueva
+        [4] - Eliminar receta
+        [5] - Eliminar categoria
+        [6] - Salir del programa''')
+        eleccion_menu = input()
+
+    return int(eleccion_menu)
+
+def mostrar_categorias(ruta):
+    print("Categorías: ")
+    ruta_categorias = Path(ruta)
+    lista_categorias = []
+    contador = 1
+
+    for carpeta in ruta_categorias.iterdir():
+        carpeta_str = str(carpeta.name)
+        print(f"[{contador}] - {carpeta_str}")
+        lista_categorias.append(carpeta)
+        contador += 1
+
+    return lista_categorias
+
+def elegir_categoria(lista):
+    eleccion_correcta = 'x'
+    while not eleccion_correcta.isnumeric() or int(eleccion_correcta) not in range(1, len(lista) + 1):
+        eleccion_correcta = input("\nElige una categoría: ")
+    return lista[int(eleccion_correcta) -1]
+
+def mostrar_recetas(ruta):
+    print("Recetas: ")
+    ruta_recetas = Path(ruta)
+    lista_recetas = []
+    contador = 1
+
+    for receta in ruta_recetas.glob("*.txt"):
+        receta_str = str(receta.name)
+        print(f"[{contador}] - {receta_str}")
+        lista_recetas.append(receta)
+        contador += 1
+    return lista_recetas
+
+def elegir_recetas(lista):
+    eleccion_receta = 'x'
+    while not eleccion_receta.isnumeric() or int(eleccion_receta)not in range(1, len(lista) + 1):
+        eleccion_receta = input("\nElige una receta: ")
+    return lista[int(eleccion_receta) - 1]
+
+def leer_receta(receta):
+    print(Path.read_text(receta))
+
+def crear_receta(ruta):
+    existe = False
+
+    while not existe:
+        print("Escribe el nombre de tu receta: ")
+        nombre_receta = input() + '.txt'
+        print("Escribe tu nueva receta: ")
+        contenido_receta = input()
+        ruta_nueva = Path(ruta, nombre_receta)
+
+        if not os.path.exists(ruta_nueva):
+            Path.write_text(ruta_nueva, contenido_receta)
+            print(f"Tu receta {nombre_receta} ha sido creada")
+            existe = True
+        else:
+            print("Lo siento, esa receta ya existe")
+
+def crear_categoria(ruta):
+    existe = False
+
+    while not existe:
+        print("Escribe el nombre de la nueva categoria: ")
+        nombre_categoria = input()
+        ruta_nueva = Path(ruta, nombre_categoria)
+
+        if not os.path.exists(ruta_nueva):
+            Path.mkdir(ruta_nueva)
+            print(f"Tu nueva categoria {nombre_categoria} ha sido creada")
+            existe = True
+        else:
+            print("Lo siento, esa categoria ya existe")
+
+def eliminar_receta(receta):
+    Path(receta).unlink()
+    print(f"La receta {receta.name} ha sido eliminada")
+
+def eliminar_categoria(categoria):
+    Path(categoria).rmdir()
+    print(f"La categoria {categoria.name} ha sido eliminada")
+
+def volver_inicio():
+    eleccion_regresar = 'x'
+    while eleccion_regresar.lower() != 'v':
+        eleccion_regresar = input('\nPresiona V para volver al menú: ')
+
+
+finalizar_programa = False
+
+while not finalizar_programa:
+    menu = inicio()
+
+    if menu == 1:
+        mis_categorias = mostrar_categorias(mi_ruta)
+        mi_categoria = elegir_categoria(mis_categorias)
+        mis_recetas = mostrar_recetas(mi_categoria)
+        if len(mis_recetas) < 1:
+            print("No hay recetas en esta categoría.")
+        else:
+            mi_receta = elegir_recetas(mis_recetas)
+            leer_receta(mi_receta)
+        volver_inicio()
+
+    elif menu == 2:
+        mis_categorias = mostrar_categorias(mi_ruta)
+        mi_categoria = elegir_categoria(mis_categorias)
+        crear_receta(mi_categoria)
+        volver_inicio()
+
+    elif menu == 3:
+        crear_categoria(mi_ruta)
+        volver_inicio()
+
+    elif menu == 4:
+        mis_categorias = mostrar_categorias(mi_ruta)
+        mi_categoria = elegir_categoria(mis_categorias)
+        mis_recetas = mostrar_recetas(mi_categoria)
+        if len(mis_recetas) < 1:
+            print("No hay recetas en esta categoría.")
+        else:
+            mi_receta = elegir_recetas(mis_recetas)
+            eliminar_receta(mi_receta)
+        volver_inicio()
+
+    elif menu == 5:
+        mis_categorias = mostrar_categorias(mi_ruta)
+        mi_categoria = elegir_categoria(mis_categorias)
+        eliminar_categoria(mi_categoria)
+        volver_inicio()
+
+    elif menu == 6:
+        finalizar_programa = True
+
+
+
+
Index: pruebas.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>lista_numeros = [1,5,8,7,6,8,2,5,2,6,4,8,5,9,8,3,5,4,2,5,6,4]\r\nsuma_pares = 0\r\nsuma_impares = 0\r\n\r\nfor numero in lista_numeros:\r\n    if numero % 2 == 0:\r\n        suma_pares += numero\r\n        print(\"Suma de pares: \", suma_pares)\r\n    else:\r\n        suma_impares += numero\r\n        print(\"Suma de impares: \", suma_impares)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pruebas.py b/pruebas.py
--- a/pruebas.py	(revision 341eff7c711caf55b31b783511e6d377ac277e1f)
+++ b/pruebas.py	(date 1727781518881)
@@ -1,11 +1,89 @@
-lista_numeros = [1,5,8,7,6,8,2,5,2,6,4,8,5,9,8,3,5,4,2,5,6,4]
-suma_pares = 0
-suma_impares = 0
+'''def cantidad_tributos(**kwargs):
+    return len(kwargs)
+
+
+resultado = cantidad_tributos(nombre="Noe", ciudad="Jaen", pais="España")
+print(resultado)
+'''
+from random import choices
+
+'''def lista_atributos(**kwargs):
+    return list(kwargs.values())
+resultado = lista_atributos(edad = 25, profesion = "programador")
+print(resultado)'''
 
-for numero in lista_numeros:
-    if numero % 2 == 0:
-        suma_pares += numero
-        print("Suma de pares: ", suma_pares)
+
+'''def describir_persona(nombre, **kwargs):
+    descripcion = f"características de {nombre.lower()}:\n"
+
+    descripcion += "\n".join([f"{atributo}: {valor}" for atributo, valor in kwargs.items()])
+
+    print(descripcion)'''
+
+''' EJERCICIO 1
+def devolver_distintos(num1,num2,num3):
+    suma = num1 + num2 + num3
+    if suma > 15:
+        return max(num1, num2, num3)
+    elif suma < 10:
+        return min(num1, num2, num3)
     else:
-        suma_impares += numero
-        print("Suma de impares: ", suma_impares)
\ No newline at end of file
+        numeros = [num1, num2, num3]
+        numeros.sort()
+        return numeros[1]
+print(devolver_distintos(2, 5, 7))  # Devuelve 5 (número intermedio, suma = 14)
+print(devolver_distintos(4, 5, 8))  # Devuelve 8 (número mayor, suma = 17)
+print(devolver_distintos(1, 2, 3))  # Devuelve 1 (número menor, suma = 6)'''
+
+'''EJERCICIO 2
+def letras_separadas(palabra):
+    letras = sorted(set(palabra))
+    return letras
+resultado = letras_separadas("python")
+print(resultado)
+
+forma alternativa:
+def letras_unicas(palabra):
+    mi_set = set ()
+    for letra in palabra:
+        mi_set.add(letra)
+    mi_lista = list(mi_set)
+    mi_lista.sort()
+    return mi_lista
+print("cascarrabias")
+'''
+
+''' EJERCICIO 3
+def argumentos_indefinidos(*args):
+    for i in range(len(args) - 1):
+        if args[i] == 0 and args[i + 1] == 0:
+            return True
+    return False
+print(argumentos_indefinidos(5, 6, 1, 0, 0, 9, 3, 5))  # True
+print(argumentos_indefinidos(6, 0, 5, 1, 0, 3, 0, 1))  # False
+
+FORMA ALTERNATIVA:
+def cero_vecinos(*args):
+    contador = 0
+    for num in args:
+        if args[contador] == 0 and args[contador + 1] == 0
+            return True
+        else:
+            contador += 1
+    return False
+print(cero_vecinos(1,2,3,4,5,7,8,9,0,0)) este seria True
+print(cero_vecinos(1,2,3,4,5,6,7,8,9,0)) este seria False
+'''
+
+def contar_primos():
+
+
+    choices
+    funciones para pedir letra, validar letra y ver si gano
+
+
+
+    
+
+
+
Index: analizador_de_texto.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>texto = input(\"Escribe una frase: \")\r\nletras = [] #lista para las letras\r\n\r\ntexto = texto.lower() #para poner todo en minusculas\r\n\r\nletras.append(input(\"Inserta la primera letra: \").lower()) #append incluye las letras en la lista de letras\r\nletras.append(input(\"Inserta la segunda letra: \").lower()) #lower controla que todo sea minusculas\r\nletras.append(input(\"Inserta la tercera letra: \").lower())\r\n\r\nprint(\"\\n\") #salto de linea\r\nprint(\"CANTIDAD DE LETRAS\")\r\ncantidad_letras1 = texto.count(letras[0]) #esto va a contar la cantidad de esa letra en la lista letras\r\ncantidad_letras2 = texto.count(letras[1])\r\ncantidad_letras3 = texto.count(letras[2])\r\n\r\nprint(f\"Hemos encontrado la letra {letras[0]} repetida {cantidad_letras1} veces\")\r\nprint(f\"Hemos encontrado la letra {letras[1]} repetida {cantidad_letras2} veces\")\r\nprint(f\"Hemos encontrado la letra {letras[2]} repetida {cantidad_letras3} veces\")\r\n\r\nprint(\"\\n\") #salto de linea\r\nprint(\"CANTIDAD DE PALABRAS\")\r\npalabras = texto.split() #palabras va a ser una lista que va a contener todas las palabras de texto\r\nprint(f\"Hemos encontrado {len(palabras)} palabras en tu texto\")\r\n\r\nprint(\"\\n\")\r\nprint(\"LETRAS DE INICIO Y DE FIN\")\r\nletra_inicio = texto[0]\r\nletra_final = texto[-1]\r\nprint(f\"La letra inicial es '{letra_inicio}' y la letra final es '{letra_final}'\")\r\n\r\nprint(\"\\n\")\r\nprint(\"TEXTO INVERTIDO\")\r\npalabras.reverse()\r\ntexto_invertido = \" \".join(palabras)\r\nprint(f\"Si ordenamos tu texto al revés va a decir: '{texto_invertido}'\")\r\n\r\nprint(\"\\n\")\r\nprint(\"BUSCANDO LA PALABRA PYTHON\")\r\nbuscar_python = \"python\" in texto\r\ndic = {True: \"si\", False: \"no\"}\r\nprint(f\"La palabra 'python' {dic[buscar_python]} se encuentra en el texto\")\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/analizador_de_texto.py b/analizador_de_texto.py
--- a/analizador_de_texto.py	(revision 341eff7c711caf55b31b783511e6d377ac277e1f)
+++ b/analizador_de_texto.py	(date 1726757365399)
@@ -41,3 +41,4 @@
 print(f"La palabra 'python' {dic[buscar_python]} se encuentra en el texto")
 
 
+
Index: juego_adivina_el_numero.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/juego_adivina_el_numero.py b/juego_adivina_el_numero.py
--- a/juego_adivina_el_numero.py	(revision 341eff7c711caf55b31b783511e6d377ac277e1f)
+++ b/juego_adivina_el_numero.py	(date 1727109251213)
@@ -1,0 +1,27 @@
+from random import randint
+
+nombre = input("¿Cuál es tu nombre? ")
+print(f"Hola {nombre}, he pensado un número entre el 1 y 100.\nTienes solo 8 intentos para adivinar el número.¡Que te diviertas!")
+num_secreto = randint(1,100)
+
+total_intentos = 8
+intentos = 0
+
+while intentos < total_intentos:
+    numero = int(input("Elige un número entre 1 y 100: "))
+
+    intentos += 1
+
+    if numero < 1 or numero > 100:
+        print(f"Ingresa un número válido. Llevas {intentos} intentos")
+    elif numero < num_secreto:
+        print(f"Tu número es menor al número secreto. Llevas {intentos} intentos")
+    elif numero > num_secreto:
+        print(f"Tu número es mayor al número secreto. Llevas {intentos} intentos")
+    elif numero == num_secreto:
+        print(f"¡Enhorabuena {nombre}! Has adivinado en {intentos} intentos")
+        break
+else:
+    print(f"Lo siento {nombre}, has agotado los 8 intentos. El número secreto era {num_secreto}")
+
+
Index: lanzar_moneda.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lanzar_moneda.py b/lanzar_moneda.py
--- a/lanzar_moneda.py	(revision 341eff7c711caf55b31b783511e6d377ac277e1f)
+++ b/lanzar_moneda.py	(date 1727691110094)
@@ -1,0 +1,26 @@
+import random
+
+# Función que lanza una moneda y devuelve "Cara" o "Cruz"
+def lanzar_moneda():
+    return random.choice(["Cara", "Cruz"])
+
+# Función que evalúa el resultado de la moneda y actúa sobre una lista de números
+def probar_suerte(resultado_moneda, lista_numeros):
+    if resultado_moneda == "Cara":
+        print("La lista se autodestruirá")
+        return []  # Devuelve la lista vacía
+    else:
+        print("La lista fue salvada")
+        return lista_numeros  # Devuelve la lista intacta
+
+# Creamos la lista de números
+lista_numeros = [1, 2, 3, 4, 5, 6]
+
+# Llamamos a la función lanzar_moneda para obtener el resultado
+resultado = lanzar_moneda()
+
+# Llamamos a la función probar_suerte pasando el resultado y la lista de números
+lista_final = probar_suerte(resultado, lista_numeros)
+
+# Imprimimos la lista final
+print("Resultado final de la lista:", lista_final)
Index: el_ahorcado.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/el_ahorcado.py b/el_ahorcado.py
--- a/el_ahorcado.py	(revision 341eff7c711caf55b31b783511e6d377ac277e1f)
+++ b/el_ahorcado.py	(date 1727952491699)
@@ -1,0 +1,59 @@
+import random
+'''
+- Elegir una palabra al azar.
+- Mostras guiones
+- El usuario debe ingresar una letra
+- Se debe comprobar si la letra está en la palabra, si no lo está, se debe quitar un intento y pedir otra letra.
+Mostrar la lista de letras incorrectas, descontar una vida y mostrar restantes.
+- si está en la palabra, mostrarla entre los guiones.
+- Cuando la palabra esté completa, avisar de que ganó.
+- Se debe informar de cuando perdió también.
+- 10 intentos.
+'''
+# En esta función se controla la palabra que el jugador tiene que adivinar
+def palabra_azar():
+    palabra = ["perro", "gato", "reloj", "aire", "microfono"]
+    palabra_aleatoria = random.choice(palabra)
+    return palabra_aleatoria
+
+# Ocultar la palabra secreta y que aparezcan guiones
+def guiones(palabra):
+    return ["_" for _ in palabra] #lista de guiones
+
+def insertar_letra():
+    palabra_oculta = palabra_azar()
+    letras_adivinadas = guiones(palabra_oculta)
+    vidas = 6
+    letras_usadas = []
+
+    print(f"Bienvenido al juego del ahorcado, la palabra que debes adivinar es la siguiente: {letras_adivinadas}")
+
+    while vidas > 0 and "_" in letras_adivinadas:
+        letra_jugador = input("Inserta una letra: ").lower()
+        if letra_jugador in letras_usadas:
+            print(f"Ya has usado la letra {letras_usadas}.")
+            continue
+
+        letras_usadas.append(letra_jugador)
+
+        if letra_jugador in palabra_oculta:
+            for i, letra in enumerate(palabra_oculta):
+                if letra == letra_jugador:
+                    letras_adivinadas [i] = letra_jugador
+            print(f"¡Bien! La letra {letra_jugador} está en la palabra.")
+        else:
+            vidas -= 1
+            print(f"Letra incorrecta, te quedan {vidas} vidas")
+
+        print(f"Progreso actual: {' '.join(letras_adivinadas)}")
+
+        if "_" not in letras_adivinadas:
+            print(f"¡Felicidades! Adivinaste la palabra '{palabra_oculta}'.")
+            break
+    if vidas == 0:
+        print(f"Te has quedado sin vidas. La palabra era '{palabra_oculta}'.")
+
+insertar_letra()
+
+
+
